1. a#b = (a+b)^2 - najmanji prioritet
-------------------------------------------
"#"{ return new_symbol(sym.HASH, yytext()); }
-------------------------------------------
FactorMulList ::=(FactorL) HashList MulOp HashList
		  |
		 (FactorOne) HashList
		 ;
HashList ::=(HashL) HashList HashOp Factor
	 |
	  (HashOne) Factor
	;
HashOp ::=(HashOp) HASH
;
-------------------------------------------
public void visit(HashL hashL) {
		int kind1=hashL.getHashList().struct.getKind();
		int kind2=hashL.getFactor().struct.getKind();
		if (kind1==Struct.Int && kind2==Struct.Int) {
			hashL.struct =hashL.getFactor().struct ;
		}
		else {
			report_error("Greska: nekompatibilni tipovi u izrazu za # operaciju.", hashL);
			hashL.struct = Tab.noType;
		} 
	}
public void visit(HashOne hashOne) {
		hashOne.struct=hashOne.getFactor().struct;
}
-------------------------------------------
public void visit(HashL hashL) {
		Code.put(Code.add);
		Code.put(Code.dup);
		Code.put(Code.mul);
	}
-------------------------------------------

************************************************************************************************************

2. a#b = (a+b)^2 - najveci prioritet
-------------------------------------------
"#"{ return new_symbol(sym.HASH, yytext()); }
-------------------------------------------
HashList ::=(HashL) HashList HashOp TermAddList
	 |
	 (HashOne) TermAddList
	 ;
HashOp ::=(HashOp) HASH
;
-------------------------------------------
public void visit(HashL hashL) {
		int kind1=hashL.getHashList().struct.getKind();
		int kind2=hashL.getTermAddList().struct.getKind();
		if (kind1==Struct.Int && kind2==Struct.Int) {
			hashL.struct =hashL.getHashList().struct ;
		}
		else {
			report_error("Greska: nekompatibilni tipovi u izrazu za # operaciju.", hashL);
			hashL.struct = Tab.noType;
		} 
	}
    public void visit(HashOne hashOne) {
		hashOne.struct=hashOne.getTermAddList().struct;
	}
-------------------------------------------
public void visit(HashL hashL) {
		Code.put(Code.add);
		Code.put(Code.dup);
		Code.put(Code.mul);
	}
-------------------------------------------

***********************************************************************************************************

3. a#b = a^b - najveci prioritet

-------------------------------------------
"#"{ return new_symbol(sym.HASH, yytext()); }
-------------------------------------------
HashList ::=(HashL) HashList HashOp TermAddList
	 |
	 (HashOne) TermAddList
	 ;
HashOp ::=(HashOp) HASH
;
-------------------------------------------
public void visit(HashL hashL) {
		int kind1=hashL.getHashList().struct.getKind();
		int kind2=hashL.getTermAddList().struct.getKind();
		if (kind1==Struct.Int && kind2==Struct.Int) {
			hashL.struct =hashL.getHashList().struct ;
		}
		else {
			report_error("Greska: nekompatibilni tipovi u izrazu za # operaciju.", hashL);
			hashL.struct = Tab.noType;
		} 
	}
    public void visit(HashOne hashOne) {
		hashOne.struct=hashOne.getTermAddList().struct;
	}
-------------------------------------------
public void visit(HashL hashL) {
		int value=Code.get(Code.pc-1);
		value= value&0x00EF;
		Code.put(Code.pop);
		for(int x=value; x>0;x--) {
			Code.put(Code.dup);
		}
		for(int x=value; x>0;x--) {
			Code.put(Code.mul);
		}
	}
-------------------------------------------
******************************************************************************************************

3. a#b = a^b - najveci prioritet pomocu skoka

-------------------------------------------
"#"{ return new_symbol(sym.HASH, yytext()); }
-------------------------------------------
HashList ::=(HashL) HashList HashOp TermAddList
	 |
	 (HashOne) TermAddList
	 ;
HashOp ::=(HashOp) HASH
;
-------------------------------------------
public void visit(HashL hashL) {
		int kind1=hashL.getHashList().struct.getKind();
		int kind2=hashL.getTermAddList().struct.getKind();
		if (kind1==Struct.Int && kind2==Struct.Int) {
			hashL.struct =hashL.getHashList().struct ;
		}
		else {
			report_error("Greska: nekompatibilni tipovi u izrazu za # operaciju.", hashL);
			hashL.struct = Tab.noType;
		} 
	}
    public void visit(HashOne hashOne) {
		hashOne.struct=hashOne.getTermAddList().struct;
	}
-------------------------------------------
    public void visit(HashL hashL) {
    	int adr1=0,adr2=0;
    	Code.put(Code.dup2);
    	Code.put(Code.pop); //a,b,a
    	Code.put(Code.dup_x2);
    	
    	Code.put(Code.pop); // a,a,b
    	adr2=Code.pc;
    	Code.put(Code.dup);
    	Code.loadConst(0); //a,a,b,b,0
    	Code.putFalseJump(Code.ne, 0);
    	adr1=Code.pc-2;
    	// ar,a,b
    	Code.put(Code.dup_x2); //b,ar,a,b
    	Code.put(Code.pop); //b,ar,a
    	Code.put(Code.dup);
    	Code.put(Code.dup_x2); //b,a,ar,a,a
    	Code.put(Code.pop);  //b,a,ar,a
    	Code.put(Code.mul);
    	Code.put(Code.dup_x2); 
    	Code.put(Code.pop);
    	Code.put(Code.dup_x1); 
    	Code.put(Code.pop);
    	Code.loadConst(1);
    	Code.put(Code.sub);
    	Code.putJump(adr2);
    	Code.fixup(adr1);
    	Code.put(Code.pop);
    	Code.put(Code.pop);
    
    }
-------------------------------------------
******************************************************************************************************
maksimum od tri broja?
# a,b,c
-------------------------------------------
"#"{ return new_symbol(sym.HASH, yytext()); }
-------------------------------------------
HashList ::=(HashListL) HashOp TermAddList:t1 COMMA TermAddList:t2 COMMA TermAddList:t3
		  |
		  (NoHashList) TermAddList 
;
HashOp ::=(HashOp) HASH
;
-------------------------------------------
 public void visit(HashListL hashL) {
		int kind1=hashL.getTermAddList().struct.getKind();
		int kind2=hashL.getTermAddList1().struct.getKind();
		int kind3=hashL.getTermAddList2().struct.getKind();
		if (kind1==Struct.Int && kind2==Struct.Int && kind3==Struct.Int) {
			hashL.struct =hashL.getTermAddList().struct ;
		}
		else {
			report_error("Greska: nekompatibilni tipovi u izrazu za # operaciju.", hashL);
			hashL.struct = Tab.noType;
		} 
	}
   public void visit(NoHashList hashL) {
	   hashL.struct =hashL.getTermAddList().struct ;
   }
-------------------------------------------
public void visit(HashListL hashL) {
		int adr1=0, adr2=0, adr3=0, adr4=0;
		Code.put(Code.dup2);
		Code.putFalseJump(Code.ge, adr1);
		adr1=Code.pc-2;
		Code.put(Code.pop);
		Code.putJump(0);
		adr2=Code.pc-2;
		Code.fixup(adr1);
		Code.put(Code.dup_x1);
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.fixup(adr2);
		Code.put(Code.dup2);
		Code.putFalseJump(Code.ge, adr3);
		adr3=Code.pc-2;
		Code.put(Code.pop);
		Code.putJump(0);
		adr4=Code.pc-2;
		Code.fixup(adr3);
		Code.put(Code.dup_x1);
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.fixup(adr4);
		
	}
-------------------------------------------
********************************************************************************************************
koliko je puta pozvan niz? 
#niz

-------------------------------------------
"#"{ return new_symbol(sym.HASH, yytext()); }
-------------------------------------------
Factor ::= (Const) NUMBER
	    |
	   (Char) CHAR
	    |
 	   (ExprFactor) LPAREN Expr RPAREN
	    |
	    (Bool) BOOL
	    |
	    (NewFactor) NEW Type
	    |
	    (NewArrayFactor) NEW Type LBRACKET Expr RBRACKET
	    |
	    (DesignatorFactor) Designator
	    |
	    (FunctionCall) Designator LPAREN RPAREN
	    |
	    (HashArray) HashOp Designator
		   ;
HashOp ::= (HashOp) HASH
;
-------------------------------------------
 ***problem zabraniti pristup n-tom elementu niza***
-------------------------------------------
	public void visit(ArrayName arrayName) {
		Code.load(arrayName.obj);
		
		Code.load(arrayName.obj);
		Code.put(Code.dup);          //niz, niz
		Obj o=Tab.lenObj;
		int offset= o.getAdr()-Code.pc;
		Code.put(Code.call);
		Code.put2(offset);    //niz, br elem
		Code.loadConst(1); 
		Code.put(Code.sub);   // niz, indeks posl
		Code.put(Code.dup2);  // niz, indeks posl, niz, indeks posl
		Code.put(Code.aload); //*niz[posl]=* niz, indeks posl
		Code.loadConst(1);    
		Code.put(Code.add);   //*niz[posl]=niz[posl]+1*
		Code.put(Code.astore);
		
	}
	public void visit(HashArray hashArray) {
		Code.load(hashArray.getDesignator().obj);
		Code.put(Code.dup);   //niz,niz
		Obj o=Tab.lenObj;
		int offset=o.getAdr()-Code.pc;
		Code.put(Code.call);
		Code.put2(offset);   //niz,br elem
		Code.loadConst(1);
		Code.put(Code.sub); //niz, posl indeks
		Code.put(Code.aload);
	}
-------------------------------------------

*****************************************************************************************************
 a:b? c:d 

-------------------------------------------
":"			{ return new_symbol(sym.COLON, yytext()); }
"?"			{ return new_symbol(sym.QUESTION, yytext()); }

-------------------------------------------
DesignatorStatement ::= (QuestionStmt) Designator EQUAL Expr COLON Expr Question Expr Colon Expr 
-------------------------------------------
 //provjeri je li int
-------------------------------------------
public void visit(QuestionStmt assignmentStmt) {
		Code.fixup(adr2);
		Obj o = assignmentStmt.getDesignator().obj;
		Code.store(o);
	}
	public void visit(Question question) {
		Code.putFalseJump(Code.eq, 0);
		adr1= Code.pc-2;
		
	}
    public void visit(Colon colon) {
    	        Code.putJump(0);
		adr2= Code.pc-2;
		Code.fixup(adr1);
	}
-------------------------------------------













